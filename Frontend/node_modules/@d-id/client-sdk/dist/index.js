var te = /* @__PURE__ */ ((e) => (e.TRIAL = "trial", e.BASIC = "basic", e.ENTERPRISE = "enterprise", e.LITE = "lite", e.ADVANCED = "advanced", e))(te || {}), ne = /* @__PURE__ */ ((e) => (e.TRIAL = "deid-trial", e.PRO = "deid-pro", e.ENTERPRISE = "deid-enterprise", e.LITE = "deid-lite", e.ADVANCED = "deid-advanced", e.BUILD = "deid-api-build", e.LAUNCH = "deid-api-launch", e.SCALE = "deid-api-scale", e))(ne || {}), re = /* @__PURE__ */ ((e) => (e.Created = "created", e.Started = "started", e.Done = "done", e.Error = "error", e.Rejected = "rejected", e.Ready = "ready", e))(re || {}), ae = /* @__PURE__ */ ((e) => (e.Unrated = "Unrated", e.Positive = "Positive", e.Negative = "Negative", e))(ae || {}), _ = /* @__PURE__ */ ((e) => (e.Functional = "Functional", e.TextOnly = "TextOnly", e.Maintenance = "Maintenance", e.Playground = "Playground", e.DirectPlayback = "DirectPlayback", e))(_ || {}), x = /* @__PURE__ */ ((e) => (e.Embed = "embed", e.Query = "query", e.Partial = "partial", e.Answer = "answer", e.Complete = "done", e))(x || {}), ie = /* @__PURE__ */ ((e) => (e.KnowledgeProcessing = "knowledge/processing", e.KnowledgeIndexing = "knowledge/indexing", e.KnowledgeFailed = "knowledge/error", e.KnowledgeDone = "knowledge/done", e))(ie || {}), se = /* @__PURE__ */ ((e) => (e.Knowledge = "knowledge", e.Document = "document", e.Record = "record", e))(se || {}), oe = /* @__PURE__ */ ((e) => (e.Pdf = "pdf", e.Text = "text", e.Html = "html", e.Word = "word", e.Json = "json", e.Markdown = "markdown", e.Csv = "csv", e.Excel = "excel", e.Powerpoint = "powerpoint", e.Archive = "archive", e.Image = "image", e.Audio = "audio", e.Video = "video", e))(oe || {}), z = /* @__PURE__ */ ((e) => (e.Clip = "clip", e.Talk = "talk", e))(z || {}), O = /* @__PURE__ */ ((e) => (e.Start = "START", e.Stop = "STOP", e))(O || {}), B = /* @__PURE__ */ ((e) => (e.ChatAnswer = "chat/answer", e.ChatPartial = "chat/partial", e.StreamDone = "stream/done", e.StreamStarted = "stream/started", e.StreamFailed = "stream/error", e.StreamReady = "stream/ready", e.StreamCreated = "stream/created", e.StreamVideoCreated = "stream-video/started", e.StreamVideoDone = "stream-video/done", e.StreamVideoError = "stream-video/error", e.StreamVideoRejected = "stream-video/rejected", e))(B || {}), y = /* @__PURE__ */ ((e) => (e.New = "new", e.Fail = "fail", e.Connected = "connected", e.Connecting = "connecting", e.Closed = "closed", e.Completed = "completed", e.Disconnected = "disconnected", e))(y || {}), ce = /* @__PURE__ */ ((e) => (e.Amazon = "amazon", e.Microsoft = "microsoft", e.Afflorithmics = "afflorithmics", e.Elevenlabs = "elevenlabs", e))(ce || {}), de = /* @__PURE__ */ ((e) => (e.Public = "public", e.Premium = "premium", e.Private = "private", e))(de || {});
const K = "https://api.d-id.com", le = "wss://notifications.d-id.com", me = "79f81a83a67430be2bc0fd61042b8faa", F = () => Math.random().toString(16).slice(2);
function J() {
  let e = window.localStorage.getItem("did_external_key_id");
  return e || (e = Math.random().toString(16).slice(2), window.localStorage.setItem("did_external_key_id", e)), e;
}
let ge = F();
function X(e) {
  if (e.type === "bearer")
    return `Bearer ${e.token}`;
  if (e.type === "basic")
    return `Basic ${btoa(`${e.username}:${e.password}`)}`;
  if (e.type === "key")
    return `Client-Key ${e.clientKey}.${J()}_${ge}`;
  throw new Error(`Unknown auth type: ${e}`);
}
function H(e, n = K, s) {
  const a = async (t, r) => {
    const i = await fetch(n + (t != null && t.startsWith("/") ? t : `/${t}`), {
      ...r,
      headers: {
        ...r == null ? void 0 : r.headers,
        Authorization: X(e),
        "Content-Type": "application/json"
      }
    });
    if (!i.ok) {
      let o = await i.text().catch(() => "Failed to fetch");
      throw s && s(new Error(o), {
        url: t,
        options: r,
        headers: i.headers
      }), new Error(o);
    }
    return i.json();
  };
  return {
    get(t, r) {
      return a(t, {
        ...r,
        method: "GET"
      });
    },
    post(t, r, i) {
      return a(t, {
        ...i,
        body: JSON.stringify(r),
        method: "POST"
      });
    },
    delete(t, r, i) {
      return a(t, {
        ...i,
        body: JSON.stringify(r),
        method: "DELETE"
      });
    },
    patch(t, r, i) {
      return a(t, {
        ...i,
        body: JSON.stringify(r),
        method: "PATCH"
      });
    }
  };
}
function Y(e, n = K, s) {
  const a = H(e, `${n}/agents`, s);
  return {
    create(t, r) {
      return a.post("/", t, r);
    },
    getAgents(t, r) {
      return a.get(`/${t ? `?tag=${t}` : ""}`, r).then((i) => i ?? []);
    },
    getById(t, r) {
      return a.get(`/${t}`, r);
    },
    delete(t, r) {
      return a.delete(`/${t}`, void 0, r);
    },
    update(t, r, i) {
      return a.patch(`/${t}`, r, i);
    },
    newChat(t, r) {
      return a.post(`/${t}/chat`, void 0, r);
    },
    chat(t, r, i, o) {
      return a.post(`/${t}/chat/${r}`, i, o);
    },
    createRating(t, r, i, o) {
      return a.post(`/${t}/chat/${r}/ratings`, i, o);
    },
    updateRating(t, r, i, o, d) {
      return a.patch(`/${t}/chat/${r}/ratings/${i}`, o, d);
    },
    deleteRating(t, r, i, o) {
      return a.delete(`/${t}/chat/${r}/ratings/${i}`, o);
    }
  };
}
const ue = (e) => new Promise((n) => setTimeout(n, e));
function we(e) {
  return new Promise((n, s) => {
    const {
      callbacks: a,
      host: t,
      auth: r
    } = e, {
      onMessage: i = null,
      onOpen: o = null,
      onClose: d = null,
      onError: l = null
    } = a || {}, g = new WebSocket(`${t}?authorization=${X(r)}`);
    g.onmessage = i, g.onclose = d, g.onerror = (h) => {
      console.error(h), l == null || l("Websocket failed to connect", h), s(h);
    }, g.onopen = (h) => {
      o == null || o(h), n(g);
    };
  });
}
async function he(e) {
  const {
    retries: n = 1
  } = e;
  let s = null;
  for (let a = 0; (s == null ? void 0 : s.readyState) !== WebSocket.OPEN; a++)
    try {
      s = await we(e);
    } catch (t) {
      if (a === n)
        throw t;
      await ue(a * 500);
    }
  return s;
}
async function fe(e, n, s) {
  const a = s != null && s.onMessage ? [s.onMessage] : [], t = await he({
    auth: e,
    host: n,
    callbacks: {
      onError: s == null ? void 0 : s.onError,
      onMessage: (r) => {
        const i = JSON.parse(r.data);
        a.forEach((o) => o(i.event, i));
      }
    }
  });
  return {
    socket: t,
    disconnect: () => t.close(),
    subscribeToEvents: (r) => a.push(r)
  };
}
const pe = "X-Playground-Chat";
function ve(e, n, s, a) {
  const t = H(e, `${n}/agents/${s}`, a);
  return {
    createStream(r) {
      return t.post("/streams", {
        compatibility_mode: r.compatibility_mode,
        stream_warmup: r.stream_warmup,
        session_timeout: r.session_timeout
      });
    },
    startConnection(r, i, o) {
      return t.post(`/streams/${r}/sdp`, {
        session_id: o,
        answer: i
      });
    },
    addIceCandidate(r, i, o) {
      return t.post(`/streams/${r}/ice`, {
        session_id: o,
        ...i
      });
    },
    sendStreamRequest(r, i, o) {
      return t.post(`/streams/${r}`, {
        session_id: i,
        ...o
      });
    },
    close(r, i) {
      return t.delete(`/streams/${r}`, {
        session_id: i
      });
    }
  };
}
function ye(e, n, s, a) {
  const t = H(e, `${n}/agents/${s}`, a);
  return {
    createStream(r, i) {
      return t.post("/streams", {
        driver_url: r.driver_url,
        face: r.face,
        config: r.config,
        compatibility_mode: r.compatibility_mode,
        stream_warmup: r.stream_warmup,
        output_resolution: r.output_resolution,
        session_timeout: r.session_timeout
      }, i);
    },
    startConnection(r, i, o, d) {
      return t.post(`/streams/${r}/sdp`, {
        session_id: o,
        answer: i
      }, d);
    },
    addIceCandidate(r, i, o, d) {
      return t.post(`/streams/${r}/ice`, {
        session_id: o,
        ...i
      }, d);
    },
    sendStreamRequest(r, i, o, d) {
      return t.post(`/streams/${r}`, {
        session_id: i,
        ...o
      }, d);
    },
    close(r, i, o) {
      return t.delete(`/streams/${r}`, {
        session_id: i
      }, o);
    }
  };
}
let Z = !1;
const b = (e, n) => Z && console.log(e, n), Ce = (window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection).bind(window);
function j(e) {
  switch (e) {
    case "connected":
      return y.Connected;
    case "checking":
      return y.Connecting;
    case "failed":
      return y.Fail;
    case "new":
      return y.New;
    case "closed":
      return y.Closed;
    case "disconnected":
      return y.Disconnected;
    case "completed":
      return y.Completed;
    default:
      return y.New;
  }
}
function Me() {
  let e = 0;
  return (n) => {
    for (const s of n.values())
      if (s && s.type === "inbound-rtp" && s.kind === "video") {
        const a = s.bytesReceived, t = a - e > 0;
        return e = a, t;
      }
    return !1;
  };
}
function _e(e, n) {
  const a = Math.max(Math.ceil(10), 1);
  let t = 0, r = !1;
  const i = Me();
  return setInterval(async () => {
    const o = await e.getStats();
    i(o) ? (t = 0, r || (n == null || n(O.Start), r = !0)) : r && (t++, t >= a && (n == null || n(O.Stop), r = !1));
  }, 100);
}
async function ke(e, n, {
  debug: s = !1,
  callbacks: a,
  auth: t,
  baseURL: r = K,
  warmup: i
}) {
  Z = s;
  let o;
  const {
    startConnection: d,
    sendStreamRequest: l,
    close: g,
    createStream: h,
    addIceCandidate: k
  } = n.videoType === z.Clip ? ve(t, r, e, a.onError) : ye(t, r, e, a.onError), {
    id: M,
    offer: T,
    ice_servers: W,
    session_id: I
  } = await h(n), p = new Ce({
    iceServers: W
  });
  if (!I)
    throw new Error("Could not create session_id");
  const c = _e(p, a.onVideoStateChange);
  p.onicecandidate = (m) => {
    b("peerConnection.onicecandidate", m), m.candidate && m.candidate.sdpMid && m.candidate.sdpMLineIndex !== null ? k(M, {
      candidate: m.candidate.candidate,
      sdpMid: m.candidate.sdpMid,
      sdpMLineIndex: m.candidate.sdpMLineIndex
    }, I) : k(M, {
      candidate: null
    }, I);
  }, p.oniceconnectionstatechange = () => {
    var f;
    b("peerConnection.oniceconnectionstatechange => " + p.iceConnectionState);
    const m = j(p.iceConnectionState);
    m === y.Connected ? o = setTimeout(() => {
      var w;
      return (w = a.onConnectionStateChange) == null ? void 0 : w.call(a, y.Connected);
    }, i ? 5e3 : 0) : (clearTimeout(o), (f = a.onConnectionStateChange) == null || f.call(a, m));
  }, p.ontrack = (m) => {
    var f;
    b("peerConnection.ontrack", m), (f = a.onSrcObjectReady) == null || f.call(a, m.streams[0]);
  }, await p.setRemoteDescription(T), b("set remote description OK");
  const u = await p.createAnswer();
  return b("create answer OK"), await p.setLocalDescription(u), b("set local description OK"), await d(M, u, I), b("start connection OK"), {
    /**
     * Method to send request to server to get clip or talk depend on you payload
     * @param payload
     */
    speak(m) {
      return l(M, I, m);
    },
    /**
     * Method to close RTC connection
     */
    async disconnect() {
      var m, f;
      if (M) {
        const w = j(p.iceConnectionState);
        if (p) {
          if (w === y.New) {
            (m = a.onVideoStateChange) == null || m.call(a, O.Stop), clearInterval(c);
            return;
          }
          p.close(), p.oniceconnectionstatechange = null, p.onnegotiationneeded = null, p.onicecandidate = null, p.ontrack = null;
        }
        try {
          w === y.Connected && await g(M, I).catch((v) => {
          });
        } catch (v) {
          b("Error on close stream connection", v);
        }
        (f = a.onVideoStateChange) == null || f.call(a, O.Stop), clearInterval(c);
      }
    },
    /**
     * Session identifier information, should be returned in the body of all streaming requests
     */
    sessionId: I,
    /**
     * Id of current RTC stream
     */
    streamId: M
  };
}
let V = {};
function Se(e) {
  const n = window != null && window.hasOwnProperty("DID_AGENTS_API") ? "agents-ui" : "agents-sdk", s = e.agent.presenter, a = {
    token: e.token || "testKey",
    distinct_id: e.distinctId || J(),
    agentId: e.agent.id,
    agentType: s.type === "clip" && s.presenter_id.startsWith("v2_") ? "clip_v2" : s.type,
    owner_id: e.agent.owner_id ?? ""
  };
  return {
    ...a,
    isEnabled: e.isEnabled ?? !0,
    getRandom: () => Math.random().toString(16).slice(2),
    track(t, r) {
      if (!this.isEnabled)
        return Promise.reject("MixPanel analytics is disabled on creation");
      const {
        audioPath: i,
        ...o
      } = r || {}, d = {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          data: JSON.stringify([{
            event: t,
            properties: {
              ...o,
              ...a,
              source: n,
              time: Date.now(),
              $insert_id: this.getRandom(),
              origin: window.location.href,
              "Screen Height": window.screen.height || window.innerWidth,
              "Screen Width": window.screen.width || window.innerHeight,
              "User Agent": navigator.userAgent
            }
          }])
        })
      };
      return fetch("https://api-js.mixpanel.com/track/?verbose=1&ip=1", d).then((l) => l.json()).catch((l) => console.error(l));
    },
    linkTrack(t, r, i, o) {
      V[t] || (V[t] = {
        events: {},
        resolvedDependencies: []
      }), o.includes(i) || o.push(i);
      const d = V[t];
      if (d.events[i] = {
        props: r
      }, d.resolvedDependencies.push(i), o.every((g) => d.resolvedDependencies.includes(g))) {
        const g = o.reduce((h, k) => d.events[k] ? {
          ...h,
          ...d.events[k].props
        } : h, {});
        this.track(t, g), d.resolvedDependencies = d.resolvedDependencies.filter((h) => !o.includes(h)), o.forEach((h) => {
          delete d.events[h];
        });
      }
    }
  };
}
function Ie(e) {
  var t, r, i, o;
  const n = () => /Mobi|Android/i.test(navigator.userAgent) ? "Mobile" : "Desktop", s = () => {
    const d = navigator.platform;
    return d.toLowerCase().includes("win") ? "Windows" : d.toLowerCase().includes("mac") ? "Mac OS X" : d.toLowerCase().includes("linux") ? "Linux" : "Unknown";
  }, a = e.presenter;
  return {
    $os: `${s()}`,
    isMobile: `${n() == "Mobile"}`,
    browser: navigator.userAgent,
    origin: window.location.origin,
    agentType: a.type === "clip" && a.presenter_id.startsWith("v2_") ? "clip_v2" : a.type,
    agentVoice: {
      voiceId: (r = (t = e.presenter) == null ? void 0 : t.voice) == null ? void 0 : r.voice_id,
      provider: (o = (i = e.presenter) == null ? void 0 : i.voice) == null ? void 0 : o.type
    }
  };
}
function Re(e, n, s) {
  var l, g;
  const {
    event: a,
    ...t
  } = e, {
    template: r
  } = (n == null ? void 0 : n.llm) || {}, {
    language: i
  } = ((l = n == null ? void 0 : n.presenter) == null ? void 0 : l.voice) || {}, {
    stitch: o
  } = (n == null ? void 0 : n.presenter) || {};
  return {
    ...t,
    llm: {
      ...t.llm,
      template: r
    },
    script: {
      ...t.script,
      provider: {
        ...(g = t == null ? void 0 : t.script) == null ? void 0 : g.provider,
        language: i
      }
    },
    stitch: o,
    ...s
  };
}
let D = 0;
function Ee(e, n) {
  var s, a, t, r, i, o, d;
  return e.presenter.type === z.Clip ? {
    videoType: z.Clip,
    session_timeout: (s = n == null ? void 0 : n.streamOptions) == null ? void 0 : s.sessionTimeout,
    stream_warmup: (a = n == null ? void 0 : n.streamOptions) == null ? void 0 : a.streamWarmup,
    compatibility_mode: (t = n == null ? void 0 : n.streamOptions) == null ? void 0 : t.compatibilityMode
  } : {
    videoType: z.Talk,
    session_timeout: (r = n == null ? void 0 : n.streamOptions) == null ? void 0 : r.sessionTimeout,
    stream_warmup: (i = n == null ? void 0 : n.streamOptions) == null ? void 0 : i.streamWarmup,
    compatibility_mode: (o = n == null ? void 0 : n.streamOptions) == null ? void 0 : o.compatibilityMode,
    output_resolution: (d = n == null ? void 0 : n.streamOptions) == null ? void 0 : d.outputResolution
  };
}
function Q(e) {
  return e === _.Playground ? {
    headers: {
      [pe]: "true"
    }
  } : {};
}
async function G(e, n, s, a) {
  try {
    const t = await n.newChat(e, Q(a));
    return s.track("agent-chat", {
      event: "created",
      chat_id: t.id,
      agent_id: e,
      mode: a
    }), t;
  } catch (t) {
    try {
      console.error(t);
      const r = JSON.parse(t.message);
      if ((r == null ? void 0 : r.kind) === "InsufficientCreditsError")
        throw new Error("InsufficientCreditsError");
    } catch (r) {
      console.error("Error parsing the error message:", r);
    }
    throw new Error("Cannot create new chat");
  }
}
function $e(e, n, s, a, t) {
  return new Promise(async (r, i) => {
    var d;
    D = 0;
    const o = await ke(e.id, Ee(e, n), {
      ...n,
      analytics: a,
      warmup: (d = n.streamOptions) == null ? void 0 : d.streamWarmup,
      callbacks: {
        ...n.callbacks,
        onConnectionStateChange: async (l) => {
          var g, h;
          l === y.Connected && (!t && n.mode !== _.DirectPlayback && (t = await G(e.id, s, a, n.mode).catch((k) => {
            i(k);
          })), o ? r({
            chat: t,
            streamingManager: o
          }) : t && i(new Error("Something went wrong while initializing the manager"))), (h = (g = n.callbacks).onConnectionStateChange) == null || h.call(g, l);
        },
        onVideoStateChange(l) {
          var g, h;
          (h = (g = n.callbacks).onVideoStateChange) == null || h.call(g, l), D > 0 && l === O.Start && a.linkTrack("agent-video", {
            event: "start",
            latency: Date.now() - D
          }, "start", [B.StreamVideoCreated]);
        }
      }
    }).catch(i);
  });
}
function q(e) {
  let n = "";
  if (e.greetings && e.greetings.length > 0) {
    const s = Math.floor(Math.random() * e.greetings.length);
    n = e.greetings[s];
  } else
    n = `Hi! I'm ${e.preview_name || "My Agent"}. How can I help you?`;
  return [{
    content: n,
    id: F(),
    role: "assistant",
    created_at: (/* @__PURE__ */ new Date()).toISOString()
  }];
}
function Ae(e) {
  if (e.answer !== void 0)
    return e.answer;
  let n = 0, s = "";
  for (; n in e; )
    s += e[n], n++;
  return s;
}
function be(e, n, s, a, t) {
  if (!(e === x.Partial || e === x.Answer))
    return;
  const r = a.messages[a.messages.length - 1];
  if ((r == null ? void 0 : r.role) !== "assistant")
    return;
  const {
    content: i,
    sequence: o
  } = n;
  e === x.Partial ? s[o] = i : s.answer = i;
  const d = Ae(s);
  (r.content !== d || e === x.Answer) && (r.content = d, t == null || t([...a.messages], e));
}
async function Pe(e, n) {
  var W, I, p;
  let s = {}, a = !0;
  const t = {
    messages: [],
    chatMode: n.mode || _.Functional
  }, r = n.baseURL || K, i = n.wsURL || le, o = n.mixpanelKey || me, d = Y(n.auth, r, n.callbacks.onError), l = await d.getById(e);
  t.messages = q(l), (I = (W = n.callbacks).onNewMessage) == null || I.call(W, [...t.messages], "answer");
  const g = Se({
    token: o,
    agent: l,
    ...n
  });
  g.track("agent-sdk", {
    event: "loaded",
    ...Ie(l)
  });
  const h = {
    onMessage: (c, u) => {
      var m, f;
      if ("content" in u)
        be(c, u, s, t, n.callbacks.onNewMessage), c === x.Answer && g.track("agent-message-received", {
          messages: t.messages.length,
          mode: t.chatMode
        });
      else {
        const w = B, v = [w.StreamVideoDone, w.StreamVideoError, w.StreamVideoRejected], R = [w.StreamFailed, w.StreamVideoError, w.StreamVideoRejected], S = Re(u, l, {
          mode: t.chatMode
        });
        if (c = c, c === w.StreamVideoCreated)
          g.linkTrack("agent-video", S, w.StreamVideoCreated, ["start"]);
        else if (v.includes(c)) {
          const C = c.split("/")[1];
          g.track("agent-video", {
            ...S,
            event: C
          });
        }
        R.includes(c) && ((f = (m = n.callbacks).onError) == null || f.call(m, new Error(`Stream failed with event ${c}`), {
          data: u
        })), u.event === w.StreamDone && M();
      }
    }
  };
  async function k(c) {
    var R, S, C, E, N, A, $;
    (S = (R = n.callbacks).onConnectionStateChange) == null || S.call(R, y.Connecting), D = 0, c && !a && (delete t.chat, t.messages = q(l), (E = (C = n.callbacks).onNewMessage) == null || E.call(C, [...t.messages], "answer"));
    const u = n.mode === _.DirectPlayback ? Promise.resolve(void 0) : fe(n.auth, i, h), m = $e(l, n, d, g, t.chat).catch((P) => {
      var L, U;
      throw T(_.Maintenance), (U = (L = n.callbacks).onConnectionStateChange) == null || U.call(L, y.Fail), P;
    }), [f, {
      streamingManager: w,
      chat: v
    }] = await Promise.all([u, m]);
    v && v.id !== ((N = t.chat) == null ? void 0 : N.id) && (($ = (A = n.callbacks).onNewChat) == null || $.call(A, v.id)), t.streamingManager = w, t.socketManager = f, t.chat = v, a = !1, T((v == null ? void 0 : v.chat_mode) ?? n.mode ?? _.Functional);
  }
  async function M() {
    var c, u, m, f;
    (c = t.socketManager) == null || c.disconnect(), await ((u = t.streamingManager) == null ? void 0 : u.disconnect()), delete t.streamingManager, delete t.socketManager, (f = (m = n.callbacks).onConnectionStateChange) == null || f.call(m, y.Disconnected);
  }
  async function T(c) {
    var u, m;
    c !== t.chatMode && (g.track("agent-mode-change", {
      mode: c
    }), t.chatMode = c, t.chatMode !== _.Functional && await M(), (m = (u = n.callbacks).onModeChange) == null || m.call(u, c));
  }
  return {
    agent: l,
    starterMessages: ((p = l.knowledge) == null ? void 0 : p.starter_message) || [],
    changeMode: T,
    async connect() {
      var c;
      await k(!0), g.track("agent-chat", {
        event: "connect",
        chatId: (c = t.chat) == null ? void 0 : c.id,
        agentId: l.id,
        mode: t.chatMode
      });
    },
    async reconnect() {
      var c;
      await M(), await k(!1), g.track("agent-chat", {
        event: "reconnect",
        chatId: (c = t.chat) == null ? void 0 : c.id,
        agentId: l.id,
        mode: t.chatMode
      });
    },
    async disconnect() {
      var c;
      await M(), g.track("agent-chat", {
        event: "disconnect",
        chatId: (c = t.chat) == null ? void 0 : c.id,
        agentId: l.id,
        mode: t.chatMode
      });
    },
    async chat(c) {
      var m, f, w, v, R, S;
      const u = F();
      s = {};
      try {
        if (D = Date.now(), n.mode === _.DirectPlayback)
          throw new Error("Direct playback is enabled, chat is disabled");
        if (c.length >= 800)
          throw new Error("Message cannot be more than 800 characters");
        if (c.length === 0)
          throw new Error("Message cannot be empty");
        if (t.chatMode === _.Maintenance)
          throw new Error("Chat is in maintenance mode");
        if (![_.TextOnly, _.Playground].includes(t.chatMode))
          if (t.streamingManager) {
            if (!t.chat)
              throw new Error("Chat is not initialized");
          } else
            throw new Error("Streaming manager is not initialized");
        t.messages.push({
          id: F(),
          role: "user",
          content: c,
          created_at: new Date(D).toISOString()
        }), (f = (m = n.callbacks).onNewMessage) == null || f.call(m, [...t.messages], "user"), t.chat || (t.chat = await G(l.id, d, g, t.chatMode), (v = (w = n.callbacks).onNewChat) == null || v.call(w, t.chat.id));
        const C = {
          id: u,
          role: "assistant",
          content: "",
          created_at: (/* @__PURE__ */ new Date()).toISOString(),
          matches: []
        }, E = [...t.messages];
        t.messages.push(C);
        const N = ($) => {
          var P, L;
          return d.chat(l.id, $, {
            sessionId: (P = t.streamingManager) == null ? void 0 : P.sessionId,
            streamId: (L = t.streamingManager) == null ? void 0 : L.streamId,
            chatMode: t.chatMode,
            messages: E.map(({
              matches: U,
              ...ee
            }) => ee)
          }, Q(t.chatMode));
        }, A = await N(t.chat.id).catch(async ($) => {
          var P;
          if (!((P = $ == null ? void 0 : $.message) != null && P.includes("missing or invalid session_id")))
            throw $;
          return await M(), await k(!1), N(t.chat.id);
        });
        return g.track("agent-message-send", {
          event: "success",
          mode: t.chatMode,
          messages: t.messages.length + 1
        }), C.context = A.context, C.matches = A.matches, A.result && (C.content = A.result, g.track("agent-message-received", {
          latency: Date.now() - D,
          mode: t.chatMode,
          messages: t.messages.length
        }), (S = (R = n.callbacks).onNewMessage) == null || S.call(R, [...t.messages], "answer")), A;
      } catch (C) {
        throw t.messages[t.messages.length - 1].id === u && t.messages.pop(), g.track("agent-message-send", {
          event: "error",
          mode: t.chatMode,
          messages: t.messages.length
        }), C;
      }
    },
    rate(c, u, m) {
      var v, R, S, C;
      const f = t.messages.find((E) => E.id === c);
      if (t.chat) {
        if (!f)
          throw new Error("Message not found");
      } else
        throw new Error("Chat is not initialized");
      const w = ((v = f.matches) == null ? void 0 : v.map((E) => [E.document_id, E.id])) ?? [];
      return g.track("agent-rate", {
        event: m ? "update" : "create",
        thumb: u === 1 ? "up" : "down",
        knowledge_id: ((R = l.knowledge) == null ? void 0 : R.id) ?? "",
        mode: t.chatMode,
        matches: w,
        score: u
      }), m ? d.updateRating(l.id, t.chat.id, m, {
        knowledge_id: ((S = l.knowledge) == null ? void 0 : S.id) ?? "",
        message_id: c,
        matches: w,
        score: u
      }) : d.createRating(l.id, t.chat.id, {
        knowledge_id: ((C = l.knowledge) == null ? void 0 : C.id) ?? "",
        message_id: c,
        matches: w,
        score: u
      });
    },
    deleteRate(c) {
      var u;
      if (!t.chat)
        throw new Error("Chat is not initialized");
      return g.track("agent-rate-delete", {
        type: "text",
        chat_id: (u = t.chat) == null ? void 0 : u.id,
        id: c,
        mode: t.chatMode
      }), d.deleteRating(l.id, t.chat.id, c);
    },
    speak(c) {
      if (!t.streamingManager)
        throw new Error("Please connect to the agent first");
      function u() {
        if (typeof c == "string") {
          if (!l.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: l.presenter.voice,
            input: c,
            ssml: !1
          };
        }
        if (c.type === "text" && !c.provider) {
          if (!l.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: l.presenter.voice,
            input: c.input,
            ssml: c.ssml
          };
        }
        return c;
      }
      const m = u();
      return g.track("agent-speak", m), t.streamingManager.speak({
        script: m
      });
    }
  };
}
function De(e, n, s) {
  const {
    getById: a
  } = Y(n, s || K);
  return a(e);
}
export {
  re as AgentStatus,
  _ as ChatMode,
  x as ChatProgress,
  y as ConnectionState,
  oe as DocumentType,
  se as KnowledgeType,
  ne as PlanGroup,
  ce as Providers,
  ae as RateState,
  B as StreamEvents,
  O as StreamingState,
  ie as Subject,
  te as UserPlan,
  z as VideoType,
  de as VoiceAccess,
  Pe as createAgentManager,
  De as getAgent
};
